#!/usr/bin/env python3
#
# This file is part of logproxy.
#
# logproxy is free software: you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# logproxy is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Foobar.  If not, see <http://www.gnu.org/licenses/>.

import contextlib
import socket
import socketserver
import sys
import urllib.parse


@contextlib.contextmanager
def timeout(sock):
    timeout = sock.gettimeout()
    sock.settimeout(1.0)

    try:
        yield
    except socket.timeout:
        # Done.
        print("timed out")
        pass
    finally:
        sock.settimeout(timeout)


def read_socket(sock):
    CHUNK_SIZE = 4096

    data = bytearray()
    with timeout(sock):
        while True:
            buf = sock.recv(CHUNK_SIZE)
            if not buf:
                break
            data.extend(buf)
    return data


def get_port(parsed):
    PORTS = {
        'http': 80,
        'https': 443,
    }
    return parsed.port or PORTS[parsed.scheme]


class ProxyHandler(socketserver.BaseRequestHandler):
    CHUNK_SIZE = 4096

    def handle(self):
        data = self.read_request(self.request)
        lines = data.splitlines(True)
        for line in lines:
            sys.stdout.buffer.write(b'> ')
            sys.stdout.buffer.write(line.strip())
            sys.stdout.buffer.write(b'\n')
            if line == b'\r\n':
                break
        sys.stdout.flush()

        method, url, version = lines[0].decode('ascii').split()
        parsed = urllib.parse.urlsplit(url)

        # Rebuild URL without host
        url = urllib.parse.urlunsplit(
            ('', '', parsed.path, parsed.query, parsed.fragment))
        line = '%s %s %s\r\n' % (method, url, version)

        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:
            sock.connect((parsed.hostname, get_port(parsed)))
            sock.setblocking(False)
            sock.send(line.encode('ascii'))
            sock.send(b''.join(lines[1:]))
            data = read_socket(sock)

        for line in data.splitlines(True):
            sys.stdout.buffer.write(b'< ')
            sys.stdout.buffer.write(line.strip())
            sys.stdout.buffer.write(b'\n')
            if line == b'\r\n':
                break
        sys.stdout.buffer.write(b'\n')
        sys.stdout.flush()

        self.request.sendall(data)

    def read_request(self, sock):
        data = bytearray()
        while not self.read_request_finished(data):
            data.extend(sock.recv(self.CHUNK_SIZE))
        return bytes(data)

    def read_request_finished(self, data):
        headers_finished = False
        content_length = 0
        content_pos = 0
        for line in data.splitlines(True):
            content_pos += len(line)
            if line == b'\r\n':
                headers_finished = True
                break
            header = line.split(b':', 1)
            if len(header) == 2:
                field, value = header
                if field.strip().lower() == b'content-length':
                    content_length = int(value.strip())
        return headers_finished and len(data[content_pos:]) == content_length


if __name__ == '__main__':
    HOST, PORT = '', 8888
    server = socketserver.TCPServer((HOST, PORT), ProxyHandler)
    try:
        server.serve_forever()
    except KeyboardInterrupt:
        sys.stdout.write('\nCtrl-C detected\n')
    finally:
        sys.stdout.write('Shutting down\n')
        server.server_close()
