#!/usr/bin/env python3
#
# This file is part of logproxy.
#
# logproxy is free software: you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# logproxy is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Foobar.  If not, see <http://www.gnu.org/licenses/>.

import socket
import socketserver
import sys
import urllib.parse


def read_socket(sock):
    BUF_LEN = 4096

    timeout = sock.gettimeout()
    sock.settimeout(1.0)

    data = bytearray()
    try:
        while True:
            buf = sock.recv(BUF_LEN)
            if not buf:
                break
            data.extend(buf)
    except socket.timeout:
        # Done.
        pass

    sock.settimeout(timeout)
    return data


def get_port(parsed):
    PORTS = {
        'http': 80,
        'https': 443,
    }
    return parsed.port or PORTS[parsed.scheme]


class ProxyHandler(socketserver.BaseRequestHandler):
    BUF_LEN = 4096

    def handle(self):
        data = self.read_request(self.request)
        lines = data.splitlines(True)
        for line in lines:
            sys.stdout.buffer.write(b'> ')
            sys.stdout.buffer.write(line.strip())
            sys.stdout.buffer.write(b'\n')
            if line == b'\r\n':
                break
        sys.stdout.flush()

        method, url, version = lines[0].decode('ascii').split()
        parsed = urllib.parse.urlsplit(url)

        # Rebuild URL without host
        url = urllib.parse.urlunsplit(
            ('', '', parsed.path, parsed.query, parsed.fragment))
        line = '%s %s %s\r\n' % (method, url, version)

        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:
            sock.connect((parsed.hostname, get_port(parsed)))
            sock.setblocking(False)
            sock.send(line.encode('ascii'))
            sock.send(b''.join(lines[1:]))
            data = read_socket(sock)

        for line in data.splitlines(True):
            sys.stdout.buffer.write(b'< ')
            sys.stdout.buffer.write(line.strip())
            sys.stdout.buffer.write(b'\n')
            if line == b'\r\n':
                break
        sys.stdout.buffer.write(b'\n')
        sys.stdout.flush()

        self.request.sendall(data)

    def read_request(self, sock):
        data = bytearray()
        while not data.endswith(b'\r\n\r\n'):
            data.extend(sock.recv(self.BUF_LEN))
        return bytes(data)


if __name__ == '__main__':
    HOST, PORT = '', 8888
    server = socketserver.TCPServer((HOST, PORT), ProxyHandler)
    try:
        server.serve_forever()
    except KeyboardInterrupt:
        sys.stdout.write('\nCtrl-C detected\n')
    finally:
        sys.stdout.write('Shutting down\n')
        server.close()
